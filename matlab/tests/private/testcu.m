function [mrec, output] = testcu(solver, problem, options)
%

% Specify the paths to the directories containing the mex files and
% probinfo.mat, which were generated by getcu.m.
probinfomat = fullfile(cutest_dir(), 'probinfo', 'probinfo.mat');

testedprob = './problem.test'; % This file records the list of tested problems.

datadir = './test_data/'; % This directory contains seed.testcu.mat.
system(['mkdir -p ', datadir]);

if (nargin < 2)
    error(sprintf('\n\nsolver and problem must be specified.\n\n'));
elseif (nargin == 2)
    options = [];
end

if (nargin==3 && ~isempty(options))
    if (isfield(options, 'seed')) % Seed is specified.
        seed = options.seed;
    elseif (isfield(options, 'reproduce') && options.reproduce == true) % Set options.reproduce = true to reproduce the results of the last experiment.
        load(strcat(datadir,'seed.testcu.mat'), 'seed');
    else
        rng('shuffle');
        seed = ceil(1e8*rand);
        save(strcat(datadir,'seed.testcu.mat'), 'seed');
    end
else
    seed = 42;
end
output.seed = seed;

% Default options
rhobeg = 1;
rhoend = 1e-6;
maxfun_dim = 500;
maxfun = 50000;
maxit = 1000;
ftarget = -inf;
randomizex0 = 0;
noiselevel = 0;
dnoiselevel = 0;
nr = 5;
ctol = 1e-10;
cpenalty = 1e10;
type = 'ubln'; % The types of problems to test
mindim = 1; % The minimal dimension of problems to test
maxdim = 50; % The maximal dimension of problems to test
mincon = 0; % The minimal number of constraints of problems to test
maxcon = min(5000, 100*maxdim); % The maximal number of constraints of problems to test
thorough_test = 0;

options = setopt(options, rhobeg, rhoend, maxfun_dim, maxfun, maxit, ftarget, randomizex0, noiselevel, dnoiselevel, nr, ctol, cpenalty, type, mindim, maxdim, mincon, maxcon, thorough_test); % Set options

% nr, maxfun, ctol and cpenalty will be used below explicitly
nr = options.randrun;
maxfun = options.maxfun;
ctol = options.ctol;
cpenalty = options.cpenalty;
thorough_test = options.thorough_test;

% Define the list of solvers to test
if (strcmpi('ALL', solver))
    solvs = textread('solvers', '%s');
elseif (iscell(solver))
    solvs = solver;
else
    solvs = {solver};
end
ns = length(solvs);

% Define the list of problems to test.
if (strcmpi('ALL', problem))
    probs = [];
elseif (iscell(problem))
    probs = problem;
else
    probs = {problem};
end
np_max = length(probs);

% These arrays will record the function values and constraint values during the tests
frec = NaN(np_max, ns, nr, maxfun);
crec = NaN(np_max, ns, nr, maxfun);

fprob = fopen(testedprob, 'w');
if (fprob == -1)
    fprintf('Fail to open file named %s.\n', testedprob);
    return;
end

load(probinfomat, 'probinfo');

% Suppress the following warning
orig_warning_state = warning;
cellfun(@(solver) warning('off', [solver, ':Debug']), solvers);
cellfun(@(solver) warning('off', [solver, ':ChkFunval']), solvers);
cellfun(@(solver) warning('off', [solver, ':ReviseX0']), solvers);
cellfun(@(solver) warning('off', [solver, ':UnknownProbField']), solvers);
cellfun(@(solver) warning('off', [solver, ':UnknownOption']), solvers);
cellfun(@(solver) warning('off', [solver, ':InvalidMaxfun']), solvers);
cellfun(@(solver) warning('off', [solver, ':ExtremeBarrier']), solvers);
cellfun(@(solver) warning('off', [solver, ':IprintContradictFortran']), solvers);
cellfun(@(solver) warning('off', [solver, ':InvalidMaxhist']), solvers);
cellfun(@(solver) warning('off', [solver, ':InvalidNpt']), solvers);

np = 0;
tic;
for iprob = 1:length(probinfo)
    name = upper(strtrim(probinfo{iprob}.name));
    if ((isempty(probs) || any(strcmpi(probs, name))) && (np_max==1 || select_prob(probinfo{iprob}, options))) % If only one problem is specified (i.e., np_max=1), then we do not call select_prob

        np = np + 1;
        ip = np;

        fprintf('\n%d. %s:\n', np, name); % Show the problem name on screen
        fprintf(fprob, '%s\n', name); % Record the problem name in problem.test

        [fun_options, con_options] = setfunopt(name, options); % Set the options for function/constraint evaluations

        problem = macup(name);

        nfevals = NaN(ns,1);

        for ir = 1:nr
            for is = 1:ns
                solv = solvs{is};
                problem.solver = solv;
                problem.options = setsolvopt(solv, length(problem.x0), options); % Set the options for the solver
                if any(regexp(solv,'_classical'))
                    problem.options.classical = true;
                    solv = regexprep(solv, '_classical', '');
                end

                [fval_history, cv_history] = testsolv(solv, problem, thorough_test); % Test solv on problem
                if isempty([fval_history cv_history])
                    % Sometimes pdfo may return fval_history = [] and cv_history = [].
                    % For example, when it detects the problem is infeasible.
                    fval_history = NaN;
                    cv_history = NaN;
                end
                nf = length(fval_history);
                frec(ip, is, ir, 1:nf) = fval_history(1:nf);
                frec(ip, is, ir, nf+1:maxfun) = fval_history(nf);
                crec(ip, is, ir, 1:nf) = max(0, cv_history(1:nf));
                crec(ip, is, ir, nf+1:maxfun) = max(0, cv_history(nf));
                nfevals(is) = nf;
                if min(nfevals) < max(nfevals) -1
                    %keyboard
                end
            end
        end

        cutest_terminate();
    end
end
fclose(fprob);
toc;
warning(orig_warning_state); % Restore the behavior of displaying warnings

frec = frec(1:np, :, :, :); % The original size of frec is [np_max, ns, nr, maxfun]. Only frec(1:np, :, :, :) is needed.
crec = crec(1:np, :, :, :);
mrec = frec + cpenalty*crec;
mrec(crec > ctol) = NaN;
mrec(:,:,:,1) = frec(:,:,:,1) + cpenalty*crec(:,:,:,1); % Prevent mrec(:,:,:,1) from being NaN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cd(olddir);
return;

function f = evalobj(func, x, constr, fun_options)
global fval_history;
global cv_history;

% Calculate the accurate function value, and save it to fval_history.
f = func(x);
fval_history = [fval_history, f];

if (~isempty(constr))
    [cineq, ceq] = constr(x);
else
    cineq = [];
    ceq = [];
end
cv = max([0, max(cineq), max(abs(ceq))]);
if (any(isnan([cineq; ceq])))
    cv = NaN;
end
cv_history = [cv_history, cv];

% fun_options will be used in the future for generating the function values that will be fed to the solver.
% For example, impose noise
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [fval_history, cv_history] = testsolv(solv, problem, thorough_test)

global fval_history; % fval_history and cv_history are global variables; updated in each call of the objective function
global cv_history;
fval_history = [];
cv_history = [];

%%%%%%%%%%%%%%%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
if (strcmpi(solv, 'oldcobyla')) % Re-configure problem for cobyla
    problem.nlc = problem.nonlcon; % Backup the REAL nonlinear constraints in nlc
    problem.nonlcon = problem.allcon; % Copy all the constraints to nonlcon
    problem = rmfield(problem, 'allcon');
end
%%%%%%%%%%%%%%%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

[~, f, ~, output] = callsolv(solv, problem, thorough_test)

%try
%    [~, f, ~, output] = callsolv(solv, problem, thorough_test);
%    format long
%    f
%    output.funcCount
%    output
%catch exception
%    fprintf('%s encounters an error when solving %s with the following message:\n %s\n', solv, problem.name, exception.message);
%    if (~strcmpi(solv, 'fmincon'))
%        keyboard
%    end
%end

%nf = length(fval_history);
nf = output.funcCount;
if (isfield(problem.options, 'maxfun'))
    maxfun = problem.options.maxfun;
elseif (strcmpi(solv, 'fmincon'))
    maxfun = problem.options.MaxFunctionEvaluations;
else
    maxfun = nf;
end
nf = min([nf, maxfun]); % Some solvers do not respect maxfun strictly, for example, fminunc of matlab.

%fval_history = fval_history(1:nf);
%cv_history = [cv_history; inf(nf - length(cv_history))]; % It can happen that length(cv_history) < nf if the solver enconters an error; in that case, cv_history(1:nf) would be illeagle.

fval_history = output.fhist(1:nf);
if isfield(output, 'chist')
    cv_history = output.chist(1:nf);
    cv_history = [cv_history; inf(nf - length(cv_history))]; % It can happen that length(cv_history) < nf if the solver enconters an error; in that case, cv_history(1:nf) would be illeagle.
else
    cv_history = zeros(size(fval_history));
end
return;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function options = setopt(options, rhobeg, rhoend, maxfun_dim, maxfun, maxit, ftarget, randomizex0, noiselevel, dnoiselevel, nr, ctol, cpenalty, type, mindim, maxdim, mincon, maxcon, thorough_test) % Set options

if (~isfield(options, 'rhoend'))
    options.rhoend = rhoend;
end
if (~isfield(options, 'rhobeg'))
    options.rhobeg = rhobeg;
end
if (~isfield(options, 'maxfun_dim'))
    options.maxfun_dim = maxfun_dim;
end
if (~isfield(options, 'maxfun'))
    options.maxfun = maxfun;
end
if (~isfield(options, 'maxit'))
    options.maxit = maxit;
end
if (~isfield(options, 'ftarget'))
    options.ftarget = ftarget;
end
if (~isfield(options, 'ctol'))
    options.ctol = ctol;
end
if (~isfield(options, 'cpenalty'))
    options.cpenalty = cpenalty;
end
if (~isfield(options, 'randomizex0'))
    options.randomizex0 = randomizex0;
end
if (~isfield(options, 'noiselevel'))
    options.noiselevel = noiselevel;
end
if (~isfield(options, 'dnoiselevel'))
    options.dnoiselevel = dnoiselevel;
end
if (~isfield(options, 'randrun'))
    options.randrun = nr;
end
if (options.randomizex0 == 0 && options.noiselevel == 0)
    options.randrun = 1;
end
if (~isfield(options, 'type'))
    options.type = type;
end
if (~isfield(options, 'mindim'))
    options.mindim = mindim;
end
if (~isfield(options, 'maxdim'))
    options.maxdim = maxdim;
end
if (~isfield(options, 'mincon'))
    options.mincon = mincon;
end
if (~isfield(options, 'maxcon'))
    options.maxcon = maxcon;
end
if (~isfield(options, 'thorough_test'))
    options.thorough_test = thorough_test;
end
return;

function solv_options = setsolvopt(solv, n, options)

solv_options = [];
solv_options.quiet = true;
solv_options.rhobeg = options.rhobeg;
solv_options.rhoend = options.rhoend;
solv_options.maxfun = min(options.maxfun_dim*n, options.maxfun);
solv_options.ftarget = options.ftarget;
solv_options.debug = true;
solv_options.chkfunval = true;
solv_options.classical = false;
%solv_options.scale = true;

if (strcmpi(solv, 'fmincon'))
    solv_options = optimoptions('fmincon');
    solv_options.MaxFunctionEvaluations = min(options.maxfun_dim*n, options.maxfun);
    solv_options.MaxIterations = options.maxit;
    solv_options.ObjectiveLimit = options.ftarget;
    solv_options.OptimalityTolerance = options.rhoend;
    solv_options.StepTolerance = options.rhoend;
    solv_options.ConstraintTolerance = min(1e-6, options.rhoend);
end
return;

function [fun_options, con_options] = setfunopt(prob_name, options)
fun_options = []; % Options for function evaluation; For the moment, fun_options is empty; options (for example, imposing noise) can be included later.
con_options = []; % Options for constraint evaluation; For the moment, con_options is empty; options (for example, imposing noise) can be included later.
return;
function selected = select_prob(probinfo, requirements) % Decide whether a problem will be tested or not according to requirements
blacklist = {};
blacklist = [blacklist, 'LHAIFAM']; % The starting point has NaN constraint values
blacklist = [blacklist, 'GOFFIN']; % This linear-equality constrained problem is strange; when lincoa solves it, x becomes so large (up to 10e16) that the constraint values evaluated by Fortran and matlab are substentially different. Seems to be due to rounding error. Not sure.
blacklist = [blacklist, {'ARGLALE', 'ARGLBLE', 'ARGLCLE', 'MODEL', 'NASH'}]; % Problems are infeasible
blacklist = [blacklist, 'LINCONT']; % project cannot find a feasible point, neither does quadprog or fmincon
%blacklist = [blacklist, {'BLOWEYA', 'BLOWEYB', 'DTOC3', 'HUES-MOD', 'HUESTIS', 'POWELL20'}]; % Constraints are feasible, but project cannot find a feasible point
%blacklist = [blacklist, {'DEGENQP', 'DEGENQPC', 'FBRAIN2', 'FBRAIN3', 'SPECANNE'}]; % Too many constraints; test takes too much time
%blacklist = [blacklist, 'TARGUS'];  % Take a long time to solve
blacklist = [blacklist, 'GAUSS1LS', 'GAUSS2LS', 'GAUSS3LS', 'MGH17LS', 'MISRA1ALS', 'MISRA1CLS', 'NELSONLS', 'OSBORNEA','RAT43LS']; % Classical uobyqa/cobyla sufferes from infnite cycling
blacklist = [blacklist, 'DANWOODLS', 'KOEBHELB']; % Classical cobyla sufferes from infinite cycling
selected = true;
if (~contains(requirements.type, probinfo.type, 'IgnoreCase', true))
    selected = false;
elseif (probinfo.dim < requirements.mindim || probinfo.dim > requirements.maxdim)
    selected = false;
elseif (probinfo.numcon < requirements.mincon || probinfo.numcon > requirements.maxcon)
    selected = false;
elseif (any(strcmpi(probinfo.name, blacklist)))
    selected = false;
end
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function problem = build_problem(name, fun_options, con_options) % This is the place where we call CUTEst functions, including cutest_setup, cutest_terminate, cutest_obj, and cutest_cons

cutest_inf = 1e20; % In CUTEst, an upper/lower bound with value 1e20/-1e20 means no bound.

try
    cutest_terminate();
catch
    % Do nothing
end
prob = cutest_setup();

x0=prob.x;
bl = prob.bl;
bu = prob.bu;
bl(bl <= -cutest_inf) = -inf;
bu(bu >= cutest_inf) = inf;
cl = prob.cl;
cu = prob.cu;
%Can pdfo take care of this? What will pdfo do if some bounds are infinite?
cl(cl <= -cutest_inf) = -inf;
cu(cu >= cutest_inf) = inf;
linear = prob.linear;
equatn = prob.equatn;

if (min([-bl; bu]) == inf && isempty(linear)) % unconstrained problem
    ptype = 'u';
elseif (isempty(linear)) % bound constrainted problem
    ptype = 'b';
elseif (sum(linear) == length(linear)) % linearly (not only bound) constrainted problem
    ptype = 'l';
else % nonlinearly constrainted problem
    ptype = 'n';
end

if (strcmpi(ptype, 'u') || strcmpi(ptype, 'b'))
    Aeq = [];
    beq = [];
    Aineq = [];
    bineq = [];
    nonlc = [];
    nonlcon = [];
else
    leq = linear & equatn; % Linear equality constraints
    lineq = linear & ~equatn; % Linear inequality constraints
    nleq = ~linear & equatn; % Nonlinear equality constraints
    nlineq = ~linear & ~equatn; % Nonlinear equality constraints

    [consx0, J] = cutest_cons(x0); % J is the Jacobian matrix of the contraints other than bounds.
    cons0 = consx0 - J*x0; % A linear constraint looks like cl <= J*x + cons0 <= cu.
    Aeq = J(leq, :);
    beq = cu(leq) - cons0(leq);
    Aineq = [J(lineq, :); -J(lineq, :)];
    bineq = [cu(lineq) - cons0(lineq); -cl(lineq) + cons0(lineq)];
    Aineq = Aineq(bineq < inf, :); % Remove the linear contraints with infinite right-hand sides.
    bineq = bineq(bineq < inf);

    nonlc = @(x) nlc(x, @cutest_cons, cl, cu, nlineq, nleq); % Nonlinear constraints: [nlcineq, nlceq] = nonlc(x), nlcineq <= 0, nlceq = 0
    nonlcon = @(x) nlc(x, @cutest_cons, cl, cu, nlineq, nleq, con_options); % This subroutine will evaluate the nonlinear constraints accoring to con_options; nonlcon(x) may be different from nonlc(x) due to con_options; [nlcineq, nlceq] = nonlcon(x), nlcineq <= 0, nlceq = 0
    if (sum(linear) == length(linear)) % No nonlinear constraints
        nonlc = [];
        nonlcon = [];
    end
end
allc = @(x) ac(x, Aineq, bineq, Aeq, beq, bl, bu, nonlc); % All constraints including bounds: [cineq, ceq] = allc(x), cineq <= 0, ceq = 0
allcon = @(x) ac(x, Aineq, bineq, Aeq, beq, bl, bu, nonlc, con_options); % This subroutine will evaluate all the constraints including bounds accoring to con_options; allcon(x) may be different from allc(x) due to con_options; [cineq, ceq] = allcon(x), cineq <= 0, ceq = 0

if (strcmpi(ptype, 'b') || strcmpi(ptype, 'l')) % Only for bound/linearly constrained problems
     proj_options = []; % Options can be sepcified for project; for example, tolerance, max number of iterations
     [x0, ~, ~, output] = project(Aineq, bineq, Aeq, beq, bl, bu, x0, proj_options); % Project x0 to statisfy the linear constraints, because LINCOA cannot take care of infeasible starting point.
     x0cv = output.constrviolation
     if (output.constrviolation >= 1e-6) % No feasible point found
         keyboard
     end
end

problem = [];
problem.name = name;
problem.type = ptype;
problem.objective = @(x) evalobj(@cutest_obj, x, allc, fun_options);
problem.x0 = x0;
problem.Aineq = Aineq;
problem.bineq = bineq;
problem.Aeq = Aeq;
problem.beq = beq;
problem.lb = bl; % In CUTEst, the lower bound for x is bl, while in pdfo/fmincon, it is lb
problem.ub = bu;
problem.nonlcon = nonlcon;
problem.allcon = allcon;
return;

function [nlcineq, nlceq] = nlc(x, cutestcons, cl, cu, nlineq, nleq, con_options) % Nonliear constraints: nlcineq <= 0, nlceq = 0
[con_val, ~] = cutestcons(x); % Constraints: cl <= con_val <= cu
nlcineq = [con_val(nlineq); -con_val(nlineq)];
nlbineq = [cu(nlineq); -cl(nlineq)];
nlcineq = nlcineq(nlbineq < inf) - nlbineq(nlbineq < inf);
nlceq = con_val(nleq)-cu(nleq);
if (nargin == 7 && ~isempty(con_options))
% con_options will be used in the future for generating the constraint values that will be fed to the solver.
% For example, impose noise
% For the moment, do nothing
end
return;

function [cineq, ceq] = ac(x, Aineq, bineq, Aeq, beq, bl, bu, nonlc, con_options) % All constraints: cineq <= 0, ceq = 0
lcineq = [bl(bl>-inf)-x(bl>-inf); x(bu<inf)-bu(bu<inf)];
%lcineq = [x(bu<inf)-bu(bu<inf); bl(bl>-inf)-x(bl>-inf)];
if(~isempty(Aineq))
    lcineq = [Aineq*x - bineq; lcineq];
end
if (isempty(Aeq))
    lceq = [];
else
    lceq = Aeq*x - beq;
end
if (isempty(nonlc))
    nlcineq = [];
    nlceq = [];
else
    [nlcineq, nlceq] = nonlc(x); % Nonliear constraints: nlcineq <= 0, nlceq = 0
end

cineq = [lcineq; nlcineq];
ceq = [lceq; nlceq];
if (nargin == 9 && ~isempty(con_options))
% con_options will be used in the future for generating the constraint values that will be fed to the solver.
% For example, impose noise
% For the moment, do nothing
end
return;
