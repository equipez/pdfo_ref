! DEBUG_MOD is a module defining some procedures concerning debugging, 
! errors, and warnings.
!
! Coded by Zaikun Zhang in July 2020.


#include "ppf.h"


module debug_mod

implicit none
private
public :: errstop, backtr, verisym, verisize

interface verisize
    module procedure verisize_real_1, verisize_real_2
    module procedure verisize_int_1, verisize_int_2
end interface verisize


contains

    
subroutine errstop(srname, mssg)
character(len = *), intent(in) :: srname
character(len = *), intent(in) :: mssg 

#if __DEBUGGING__ == 1
call backtr()
#endif

print '(/1A/)', 'Error: ' // trim(srname) // ': ' // trim(mssg) // '.'

stop  ! This means to stop the whole program.

end subroutine errstop


subroutine backtr
! BACKTR calls a compiler-dependent intrinsic to show a backtrace if we 
! are in the debuge mode, i.e., __DEBUGGING__ == 1. 
! N.B.: 
! 1. The intrisic is compiler-dependent and does not exist in all 
! compilers. Indeed, it is not standard-conforming. Therefore, compilers
! may warn that a non-standard intrinsic is in use. 
! 2. More seriously, if the compiler is instructed to conform to the 
! standards (e.g., gfortran with the option -std=f2003) while __DEBUGGING__
! is set to 1, then the compilation may FAIL at the linking stage, 
! complaining that a subroutine cannot be found (e.g., backtrace for
! gfortran). In that case, we must set __DEBUGGING__ to 0 in ppf.h.
#if __DEBUGGING__ == 1 

#if defined __GFORTRAN__
implicit none
call backtrace
#elif defined __INTEL_COMPILER
use ifcore, only : tracebackqq
implicit none
call tracebackqq(user_exit_code = -1)
! According to "Intel Fortran Compiler 19.1 Developer Guide and Reference", item "TRACEBACKQQ":
! By specifying a user exit code of -1, control returns to the calling program. Specifying a user 
! exit code with a positive value requests that specified value be returned to the operating system. 
! The default value is 0, which causes the application to abort execution.
#endif

#endif
end subroutine backtr


subroutine verisym(A, tol)
! VERISYM verifies whether a matrix A is symmetric up to TOL.
use consts_mod, only : RP, ONE, ZERO, SRNLEN
implicit none

real(RP), intent(in) :: A(:, :)
real(RP), intent(in) :: tol

character(len = SRNLEN), parameter :: srname = 'VERISYM'

if (size(A, 1) /= size(A, 2)) then
    call errstop(srname, 'A is not square')
end if
if (tol > ZERO) then
    if (maxval(abs((A - transpose(A)))) > tol*max(maxval(abs(A)), ONE)) then
         call errstop(srname, 'A is not symmetric up to TOL')
    end if
else
    if (maxval(abs((A - transpose(A)))) > ZERO) then
         call errstop(srname, 'A is not symmetric up to TOL')
    end if
end if
end subroutine verisym


subroutine verisize_real_1(x, n)
! VERISIZE_REAL_1 verifies whether SIZE(X) = N.
use consts_mod, only : RP, IK, SRNLEN
real(RP), intent(in) :: x(:)
integer(IK), intent(in) :: n

character(len = SRNLEN), parameter :: srname = 'VERISIZE_REAL_1'

if (size(x) /= n) then
    call errstop(srname, 'SIZE(X) /= N')
end if
end subroutine verisize_real_1


subroutine verisize_real_2(x, m, n)
! VERISIZE_REAL_2 verifies whether SIZE(X, 1) = M, SIZE(X, 2) = N.
use consts_mod, only : RP, IK, SRNLEN
real(RP), intent(in) :: x(:, :)
integer(IK), intent(in) :: m
integer(IK), intent(in) :: n

character(len = SRNLEN), parameter :: srname = 'VERISIZE_REAL_2'

if (size(x, 1) /= m) then
    call errstop(srname, 'SIZE(X, 1) /= M')
end if
if (size(x, 2) /= n) then
    call errstop(srname, 'SIZE(X, 2) /= N')
end if
end subroutine verisize_real_2


subroutine verisize_int_1(x, n)
! VERISIZE_INT_1 verifies whether SIZE(X) = N.
use consts_mod, only : IK, SRNLEN
integer(IK), intent(in) :: x(:)
integer(IK), intent(in) :: n

character(len = SRNLEN), parameter :: srname = 'VERISIZE_INT_1'

if (size(x) /= n) then
    call errstop(srname, 'SIZE(X) /= N')
end if
end subroutine verisize_int_1


subroutine verisize_int_2(x, m, n)
! VERISIZE_INT_2 verifies whether SIZE(X, 1) = M, SIZE(X, 2) = N.
use consts_mod, only : IK, SRNLEN
integer(IK), intent(in) :: x(:, :)
integer(IK), intent(in) :: m
integer(IK), intent(in) :: n

character(len = SRNLEN), parameter :: srname = 'VERISIZE_INT_2'

if (size(x, 1) /= m) then
    call errstop(srname, 'SIZE(X, 1) /= M')
end if
if (size(x, 2) /= n) then
    call errstop(srname, 'SIZE(X, 2) /= N')
end if
end subroutine verisize_int_2


end module debug_mod

