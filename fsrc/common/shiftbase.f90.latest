module shiftbase_mod
!--------------------------------------------------------------------------------------------------!
! This module contanis a subroutine that shifts the base point from XBASE to XBASE + XPT.
!
! Coded by Zaikun ZHANG (www.zhangzk.net) based on Powell's Fortran 77 code and the NEWUOA paper.
!
! Dedicated to late Professor M. J. D. Powell FRS (1936--2015).
!
! Started: July 2020
!
! Last Modified: Monday, April 04, 2022 PM10:37:35
!--------------------------------------------------------------------------------------------------!

implicit none
private
public :: shiftbase


contains


subroutine shiftbase(idz, pq, zmat, bmat, gq, hq, xbase, xopt, xpt)
!--------------------------------------------------------------------------------------------------!
! SHIFTBASE shifts the base point for XBASE to XBASE + XOPT and updates GQ, HQ, and BMAT
! accordingly. PQ and ZMAT remain the same after the shifting. See Section 7 of the NEWUOA paper.
!--------------------------------------------------------------------------------------------------!
! List of local arrays (including function-output arrays; likely to be stored on the stack):
! REAL(RP) :: SUMZ(NPT-N-1), VLAG(N), SXPT(NPT), W2(N), XPQ(N)
! Size of local arrays: REAL(RP)*(2*NPT+2*N-1)
!--------------------------------------------------------------------------------------------------!

! Generic modules
use, non_intrinsic :: consts_mod, only : RP, IK, ZERO, ONE, HALF, QUART, DEBUGGING
use, non_intrinsic :: debug_mod, only : assert
use, non_intrinsic :: infnan_mod, only : is_finite
use, non_intrinsic :: linalg_mod, only : r1update, r2update, inprod, matprod, issymmetric, hess_mul,&
    & Ax_plus_y, symmetrize, outprod

implicit none

! Inputs
integer(IK), intent(in) :: idz
real(RP), intent(in) :: pq(:)   ! PQ(NPT)
real(RP), intent(in) :: zmat(:, :)  ! ZMAT(NPT, NPT - N - 1)

! In-outputs
real(RP), intent(inout) :: bmat(:, :)   ! BMAT(N, NPT + N)
real(RP), intent(inout) :: gq(:)    ! GQ(N)
real(RP), intent(inout) :: hq(:, :) ! HQ(N, N)
real(RP), intent(inout) :: xbase(:) ! XBASE(N)
real(RP), intent(inout) :: xopt(:)  ! XOPT(N)
real(RP), intent(inout) :: xpt(:, :)    ! XPT(N, NPT)

! Local variables
character(len=*), parameter :: srname = 'SHIFTBASE'
integer(IK) :: k
integer(IK) :: n
integer(IK) :: npt
real(RP) :: by(size(xopt), size(xopt))
real(RP) :: qxoptq
real(RP) :: sumz(size(zmat, 2))
real(RP) :: t
real(RP) :: sxpt(size(pq))
real(RP) :: vlag(size(xopt))
real(RP) :: xoptsq
real(RP) :: xpq(size(xopt))
real(RP) :: ymat(size(xopt), size(pq))
real(RP) :: yz(size(xopt), size(zmat, 2))
real(RP) :: yz_c(size(xopt), size(zmat, 2))
real(RP) :: xptxav(size(xpt, 1), size(xpt, 2))

! Sizes
n = int(size(xpt, 1), kind(n))
npt = int(size(xpt, 2), kind(npt))

! Preconditions
if (DEBUGGING) then
    call assert(n >= 1 .and. npt >= n + 2, 'N >= 1, NPT >= N + 2', srname)
    call assert(idz >= 1 .and. idz <= size(zmat, 2) + 1, '1 <= IDZ <= SIZE(ZMAT, 2) + 1', srname)
    call assert(size(bmat, 1) == n .and. size(bmat, 2) == npt + n, 'SIZE(BMAT)==[N, NPT+N]', srname)
    call assert(issymmetric(bmat(:, npt + 1:npt + n)), 'BMAT(:, NPT+1:NPT+N) is symmetric', srname)
    call assert(size(zmat, 1) == npt .and. size(zmat, 2) == npt - n - 1, &
        & 'SIZE(ZMAT) == [NPT, NPT - N - 1]', srname)
    call assert(size(gq) == n, 'SIZE(GQ) = N', srname)
    call assert(size(hq, 1) == n .and. issymmetric(hq), 'HQ is an NxN symmetric matrix', srname)
    call assert(size(pq) == npt, 'SIZE(PQ) = NPT', srname)
    call assert(size(xbase) == n .and. all(is_finite(xbase)), 'SIZE(XBASE) == N, XBASE is finite', srname)
    call assert(size(xopt) == n .and. all(is_finite(xopt)), 'SIZE(XOPT) == N, XOPT is finite', srname)
    call assert(all(is_finite(xpt)), 'XPT is finite', srname)
end if

!====================!
! Calculation starts !
!====================!

xoptsq = inprod(xopt, xopt)
qxoptq = QUART * xoptsq

! Update HQ. See (7.14) of the NEWUOA paper.
xptxav = xpt - HALF * spread(xopt, dim=2, ncopies=npt)
!!MATLAB: xptxav = xpt - xopt/2  % xopt should be a column!! Implicit expansion

sxpt = matprod(xopt, xptxav)
!sxpt = matprod(xopt, xpt) - HALF * xoptsq
do k = 1, npt
    ymat(:, k) = sxpt(k) * xptxav(:, k) + qxoptq * xopt
    ! Implement R2UPDATE properly so that BMAT(:, NPT+1:NPT+N) is symmetric.
    !call r2update(bmat(:, npt + 1:npt + n), ONE, bmat(:, k), ymat)
end do
!!MATLAB: ymat = xptav.*sxpt + qxoptq * xopt

!sumz = sum(zmat, dim=1)
do k = 1, npt - n - 1_IK
!    !vlag = qxoptq * sumz(k) * xopt + matprod(xpt, sxpt * zmat(:, k))  ! Should it be called VLAG or W2?
    vlag = Ax_plus_y(xpt, sxpt * zmat(:, k), qxoptq * sum(zmat(:, k)) * xopt)  ! Should it be called VLAG or W2?
!    !write (16, *) norm2(vlag - (qxoptq * sumz(k) * xopt + matprod(xpt, sxpt * zmat(:, k)))) / norm2(vlag)
!    !if (k <= idz - 1) then
!    !    t = -ONE
!    !else
!    !    t = ONE
!    !end if
!    !call r1update(bmat(:, 1:npt), t, vlag, zmat(:, k))
!    !! Implement R1UPDATE properly so that BMAT(:, NPT+1:NPT+N) is symmetric.
!    !call r1update(bmat(:, npt + 1:npt + n), t, vlag)

!    !yz(:, k) = qxoptq * sumz(k) * xopt + matprod(xpt, sxpt * zmat(:, k))
    yz(:, k) = vlag
end do

! Update BMAT. See (7.11)--(7.12) of the NEWUOA paper and the elaborations around.
! First, make the changes to BMAT that do not depend on ZMAT.
by = matprod(bmat(:, 1:npt), transpose(ymat))  ! BMAT(:, 1:NPT) is not updated yet.
bmat(:, npt + 1:npt + n) = bmat(:, npt + 1:npt + n) + (by + transpose(by))
!call symmetrize(bmat(:, npt + 1:npt + n))

! Then the revisions of BMAT that depend on ZMAT are calculated.
!yz = matprod(ymat, zmat)
yz_c(:, 1:idz - 1) = -yz(:, 1:idz - 1)
yz_c(:, idz:npt - n - 1) = yz(:, idz:npt - n - 1)
bmat(:, npt + 1:npt + n) = bmat(:, npt + 1:npt + n) + matprod(yz, transpose(yz_c))
bmat(:, 1:npt) = bmat(:, 1:npt) + matprod(yz_c, transpose(zmat))

! Update the quadratic model. Only GQ and HQ need revision.
gq = hess_mul(hq, pq, xpt, xopt) + gq
xpq = matprod(xptxav, pq)
call r2update(hq, ONE, xopt, xpq)  ! Implement R2UPDATE properly so that HQ is symmetric.
!hq = hq + (outprod(xopt, xpq) + outprod(xpq, xopt))

! The following instructions complete the shift of XBASE.
xpt = xpt - spread(xopt, dim=2, ncopies=npt)
!!MATLAB: xpt = xpt - xopt  % xopt should be a column!! Implicit expansion
xbase = xbase + xopt
xopt = ZERO

!====================!
!  Calculation ends  !
!====================!

! Postconditions
if (DEBUGGING) then
    call assert(size(bmat, 1) == n .and. size(bmat, 2) == npt + n, 'SIZE(BMAT)==[N, NPT+N]', srname)
    call assert(issymmetric(bmat(:, npt + 1:npt + n)), 'BMAT(:, NPT+1:NPT+N) is symmetric', srname)
    call assert(size(gq) == n, 'SIZE(GQ) = N', srname)
    call assert(size(hq, 1) == n .and. issymmetric(hq), 'HQ is an NxN symmetric matrix', srname)
    call assert(size(pq) == npt, 'SIZE(PQ) = NPT', srname)
    call assert(size(xopt) == n .and. all(is_finite(xopt)), 'SIZE(XOPT) == N, XOPT is finite', srname)
    call assert(size(xbase) == n .and. all(is_finite(xbase)), 'SIZE(XBASE) == N, XBASE is finite', srname)
    call assert(size(xpt, 1) == n .and. size(xpt, 2) == npt, 'SIZE(XPT) == [N, NPT]', srname)
    call assert(all(is_finite(xpt)), 'XPT is finite', srname)
end if

end subroutine shiftbase


end module shiftbase_mod
