# This Makefile intends to test the modern-Fortran version of Powell's solvers on as many compilers
# as possible.
#
# The following compilers are tested:
# 9: G95 (compilation only)
# a: Absoft af95
# d: AOCC flang
# f: LLVM flang
# g: GNU gfortran
# n: NAG nagfor
# i: Intel ifort
# s: Oracle sunf95
# v: NVIDIA nvfortran
# x: Intel ifx
#
# The following tests are available, where C = 9, a, d, f, g, n, i, s, v, x, and N = 2, 4, 8:
# Ctest: test with compiler C
# Ctest_c: test with compiler C; compilation only (do not run the binary)
# Ctest_iN: test with compiler C and integer kind INT(N*8)
# Ctest_iN_c: test with compiler C and integer kind INT(N*8); compilation only
#
# Coded by Zaikun ZHANG (www.zhangzk.net).
#
# Started: September 2021
#
# Last Modified: October 4, 2021
####################################################################################################


#$(VERBOSE).SILENT:  # Order make to work quietly. Not desirable in this case.


SHELL = /bin/bash


####################################################################################################
# Variables

# Fortran standard to follow. We aim to make the code compatible with F2003, F2008, and F2018.
FS = 03
FSTD = 20$(FS)

# Default options for all the compilers.
FFLAGS = -g -O0

# Log file stamp.
RANDNUM := $(shell awk 'BEGIN{srand();printf("%d", 65536*rand())}')
TIME := $(shell date +%Y.%m.%d_%H.%M.%S)
STAMP := $(TIME)_$(RANDNUM)

# Log directory.
LOG_DIR := ./log
# Trash directory.
TRASH_DIR := ./trash

# Common directory.
COMMON = common
COMMON_DIR = ../../$(COMMON)
# Solver directory.
SOLVER_DIR = ../../$(SOLVER)
# Test suite directory.
TESTSUITE = testsuite
TESTSUITE_DIR = ../$(TESTSUITE)
# Source directories.
SRC_DIRS = $(COMMON_DIR) $(SOLVER_DIR) $(TESTSUITE_DIR)
# Driver directory.
DRIVER_DIR = ..

# Sources.
COMMON_SRC = $(shell sed "s/^/\.\/common\//" $(COMMON_DIR)/ffiles.txt)
SOLVER_SRC = $(shell sed "s/^/\.\/$(SOLVER)\//" $(SOLVER_DIR)/ffiles.txt)
TESTSUITE_SRC = $(shell sed "s/^/\.\/$(TESTSUITE)\//" $(TESTSUITE_DIR)/ffiles.txt)
DRIVER_SRC = test_$(SOLVER).f90 test.f90
SRC = $(COMMON_SRC) $(SOLVER_SRC) $(TESTSUITE_SRC) $(DRIVER_SRC)

# Headers.
# N.B.: If we define COMMON as "./common/", then, when adapting the header, sed will complain
# that"./common//*.h" cannot be found on macOS.
HEADERS = ./$(COMMON)/*.h

# The checktest script.
CHCKTST = ../checktest

# Define the tests.
######################################################################################
# Decide whether to test QP, e.g., REAL128.
# Absoft 21.0 is buggy concerning REAL128 (but we can still test the compilation without running);
# Flang and nvfortran do not support REAL128;
# AOCC Flang complains about a symbol lookup error: undefined symbol: "fort_rnumq_i8";
# ifx encounters an internal error when compiling with REAL128.
TESTS_QP = atest gtest ntest itest stest 9test
TESTS_NO_QP = dtest ftest vtest xtest
TESTS = $(TESTS_QP) $(TESTS_NO_QP)
# When listing the tests, we first put the ones that are more likely to raise errors.
$(foreach TST, $(TESTS_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_i2_r16_d1_tst $(TST)_i2_r4_d1_tst $(TST)_i2_r8_d1_tst \
	$(TST)_i4_r16_d1_tst $(TST)_i4_r4_d1_tst $(TST)_i4_r8_d1_tst \
	$(TST)_i8_r16_d1_tst $(TST)_i8_r4_d1_tst $(TST)_i8_r8_d1_tst \
	$(TST)_i2_r16_d0_tst $(TST)_i2_r4_d0_tst $(TST)_i2_r8_d0_tst \
	$(TST)_i4_r16_d0_tst $(TST)_i4_r4_d0_tst $(TST)_i4_r8_d0_tst \
	$(TST)_i8_r16_d0_tst $(TST)_i8_r4_d0_tst $(TST)_i8_r8_d0_tst \
	))
$(foreach TST, $(TESTS_NO_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_i2_r4_d1_tst $(TST)_i2_r8_d1_tst \
	$(TST)_i4_r4_d1_tst $(TST)_i4_r8_d1_tst \
	$(TST)_i8_r4_d1_tst $(TST)_i8_r8_d1_tst \
	$(TST)_i2_r4_d0_tst $(TST)_i2_r8_d0_tst \
	$(TST)_i4_r4_d0_tst $(TST)_i4_r8_d0_tst \
	$(TST)_i8_r4_d0_tst $(TST)_i8_r8_d0_tst \
	))
$(foreach TST, $(TESTS), $(eval $(TST): TST_C := $(TST)_c))

# The following tests compiles the code but do not run the binary. This is useful if we want to
# check whether the code can compile
TESTS_C_QP = atest_c gtest_c ntest_c itest_c stest_c 9test_c
TESTS_C_NO_QP = dtest_c ftest_c vtest_c xtest_c
TESTS_C = $(TESTS_C_QP) $(TESTS_C_NO_QP)
$(foreach TST, $(TESTS_C_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_i2_r16_d1_tst_c $(subst _c,,$(TST))_i2_r4_d1_tst_c $(subst _c,,$(TST))_i2_r8_d1_tst_c \
	$(subst _c,,$(TST))_i4_r16_d1_tst_c $(subst _c,,$(TST))_i4_r4_d1_tst_c $(subst _c,,$(TST))_i4_r8_d1_tst_c \
	$(subst _c,,$(TST))_i8_r16_d1_tst_c $(subst _c,,$(TST))_i8_r4_d1_tst_c $(subst _c,,$(TST))_i8_r8_d1_tst_c \
	$(subst _c,,$(TST))_i2_r16_d0_tst_c $(subst _c,,$(TST))_i2_r4_d0_tst_c $(subst _c,,$(TST))_i2_r8_d0_tst_c \
	$(subst _c,,$(TST))_i4_r16_d0_tst_c $(subst _c,,$(TST))_i4_r4_d0_tst_c $(subst _c,,$(TST))_i4_r8_d0_tst_c \
	$(subst _c,,$(TST))_i8_r16_d0_tst_c $(subst _c,,$(TST))_i8_r4_d0_tst_c $(subst _c,,$(TST))_i8_r8_d0_tst_c \
	))
$(foreach TST, $(TESTS_C_NO_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_i2_r4_d1_tst_c $(subst _c,,$(TST))_i2_r8_d1_tst_c \
	$(subst _c,,$(TST))_i4_r4_d1_tst_c $(subst _c,,$(TST))_i4_r8_d1_tst_c \
	$(subst _c,,$(TST))_i8_r4_d1_tst_c $(subst _c,,$(TST))_i8_r8_d1_tst_c \
	$(subst _c,,$(TST))_i2_r4_d0_tst_c $(subst _c,,$(TST))_i2_r8_d0_tst_c \
	$(subst _c,,$(TST))_i4_r4_d0_tst_c $(subst _c,,$(TST))_i4_r8_d0_tst_c \
	$(subst _c,,$(TST))_i8_r4_d0_tst_c $(subst _c,,$(TST))_i8_r8_d0_tst_c \
	))

# Duration of one test by GitHub Actions:
# atest: < 1 hour
# dtest: ~30 minutes
# ftest: ~30 minutes
# gtest: 4~5 hours
# itest: > 6 hours (killed by GitHub after that)
# ntest: 3~4 hours
# stest: 4~5 hours
# vtest: 3~4 hours
# xtest: > 6 hours
# The tests with ifort, ifx, etc are slow due to the intensive runtime checks. To save time, we
# define the following tests. If itest_i2 succeeds, then itest_i4 and itest_i8 are likely (but not
# surely) to be OK, because the only difference in the code is the integer kind. Similar for others.
TESTS_INT_QP = atest_i2 atest_i4 atest_i8 \
			   gtest_i2 gtest_i4 gtest_i8 \
			   ntest_i2 ntest_i4 ntest_i8 \
			   itest_i2 itest_i4 itest_i8 \
			   stest_i2 stest_i4 stest_i8 \
			   9test_i2 9test_i4 9test_i8
TESTS_INT_NO_QP = dtest_i2 dtest_i4 dtest_i8 \
				  ftest_i2 ftest_i4 ftest_i8 \
				  vtest_i2 vtest_i4 vtest_i8 \
				  xtest_i2 xtest_i4 xtest_i8
TESTS_INT = $(TESTS_INT_QP) $(TESTS_INT_NO_QP)
$(foreach TST, $(TESTS_INT_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_r16_d1_tst $(TST)_r4_d1_tst $(TST)_r8_d1_tst \
	$(TST)_r16_d0_tst $(TST)_r4_d0_tst $(TST)_r8_d0_tst \
	))
$(foreach TST, $(TESTS_INT_NO_QP), $(eval $(TST): SUBTESTS := \
	$(TST)_r4_d1_tst $(TST)_r8_d1_tst \
	$(TST)_r4_d0_tst $(TST)_r8_d0_tst \
	))
$(foreach TST, $(TESTS_INT), $(eval $(TST): TST_C := $(TST)_c))

# The following tests compiles the code but do not run the binary. This is useful if we want to
# check whether the code can compile
TESTS_INT_C_QP = atest_i2_c atest_i4_c atest_i8_c \
				 gtest_i2_c gtest_i4_c gtest_i8_c \
				 ntest_i2_c ntest_i4_c ntest_i8_c \
				 itest_i2_c itest_i4_c itest_i8_c \
				 stest_i2_c stest_i4_c stest_i8_c \
				 9test_i2_c 9test_i4_c 9test_i8_c
TESTS_INT_C_NO_QP = dtest_i2_c dtest_i4_c dtest_i8_c \
					ftest_i2_c ftest_i4_c ftest_i8_c \
					vtest_i2_c vtest_i4_c vtest_i8_c \
					xtest_i2_c xtest_i4_c xtest_i8_c
TESTS_INT_C = $(TESTS_INT_C_QP) $(TESTS_INT_C_NO_QP)
$(foreach TST, $(TESTS_INT_C_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_r16_d1_tst_c $(subst _c,,$(TST))_r4_d1_tst_c $(subst _c,,$(TST))_r8_d1_tst_c \
	$(subst _c,,$(TST))_r16_d0_tst_c $(subst _c,,$(TST))_r4_d0_tst_c $(subst _c,,$(TST))_r8_d0_tst_c \
	))
$(foreach TST, $(TESTS_INT_C_NO_QP), $(eval $(TST): SUBTESTS_C := \
	$(subst _c,,$(TST))_r4_d1_tst_c $(subst _c,,$(TST))_r8_d1_tst_c \
	$(subst _c,,$(TST))_r4_d0_tst_c $(subst _c,,$(TST))_r8_d0_tst_c \
	))
######################################################################################

.PHONY: all test test_c clean $(TESTS) $(TESTS_C) $(TESTS_INT) $(TESTS_INT_C) source_* header_* clean*

# Operating system.
OSTYPE :=
ifeq ($(OS),Windows_NT)
	OSTYPE = WINDOWS
else
	UNAME_S := $(shell uname -s)
	ifeq ($(UNAME_S),Darwin)
		OSTYPE = MAC
	else  # We assume the OS is LINUX by default.
		OSTYPE = LINUX
	endif
endif

# Define SED.
# When calling "sed -i" on macOS, it is obligatory to specify a string (e.g., .bak) after -i as the
# extension for saving a backup. If the string is "", then no backup will be saved. If no string is
# specified, then an error will be raised, saying "invalid command code".
SED :=
ifeq ($(OSTYPE), MAC)
	SED = @sed -i ""
else
	SED = @sed -i
endif

# Define NPROCS to be the number of processors available to make tests in parallel.
# Question: How to do it in WINDOWS? $(shell echo %NUMBER_OF_PROCESSORS%) does not work.
NPROCS :=
ifeq ($(OSTYPE), LINUX)
	NPROCS = $(shell grep -c 'processor' /proc/cpuinfo || echo 1)
else ifeq ($(OSTYPE), MAC)
	NPROCS = $(shell sysctl hw.ncpu  | grep -o '[0-9]\+' || echo 1)
else
	NPROCS = 1
endif

####################################################################################################
# Here are the testing options for each compiler. We try to turn on as many debugging options as
# possible, in particular, the options regarding the following are included whenever available.
# 1. Standard conformity.
# 2. Runtime bound checking of arrays.
# 3. IEEE 754 Floating-Point Exceptions (FPE).

# Absoft af95
# 1. For af95, -Rb imposes bound checking for arrays. But it is unhappy with zero-sized arrays as of
# Absoft Pro 21.0. Thus -Rb is not included in the following options.
# 2. For Debian-based systems, -no-pie is needed; for other systems, this option may not work.
AFORT :=
ifneq ("$(wildcard /etc/debian_version)","")
	AFORT = af95 -no-pie -m1 -en -et -Rb -Rc -Rs -Rp
else
	AFORT = af95 -m1 -en -et -Rb -Rc -Rs -Rp
endif
atest_i2_r4_d1_tst_c atest_i4_r4_d1_tst_c atest_i8_r4_d1_tst_c atest_i2_r4_d0_tst_c atest_i4_r4_d0_tst_c atest_i8_r4_d0_tst_c: \
	FC = $(AFORT) -TENV:simd_zmask=off
atest_i2_r8_d1_tst_c atest_i4_r8_d1_tst_c atest_i8_r8_d1_tst_c atest_i2_r8_d0_tst_c atest_i4_r8_d0_tst_c atest_i8_r8_d0_tst_c: \
	FC = $(AFORT) \
	-TENV:simd_zmask=off -TENV:simd_omask=off -TENV:simd_imask=off #-TENV:simd_dmask=off -TENV:simd_umask=off
atest_i2_r16_d1_tst_c atest_i4_r16_d1_tst_c atest_i8_r16_d1_tst_c atest_i2_r16_d0_tst_c atest_i4_r16_d0_tst_c atest_i8_r16_d0_tst_c: \
	FC = $(AFORT) -TENV:simd_zmask=off

# AMD AOCC Flang
AFLANG := $(shell find /opt/AMD \( -type l -o -type f \) -executable -name flang -print -quit 2> /dev/null || echo AFLANG_NOT_FOUND)
DFORT = $(AFLANG) -std=f$(FSTD) -Mstandard -Wall -Wextra
dtest_i2_r4_d1_tst_c dtest_i4_r4_d1_tst_c dtest_i8_r4_d1_tst_c dtest_i2_r4_d0_tst_c dtest_i4_r4_d0_tst_c dtest_i8_r4_d0_tst_c: \
	FC = $(DFORT)
dtest_i2_r8_d1_tst_c dtest_i4_r8_d1_tst_c dtest_i8_r8_d1_tst_c dtest_i2_r8_d0_tst_c dtest_i4_r8_d0_tst_c dtest_i8_r8_d0_tst_c: \
	FC = $(DFORT) -ffp-exception-behavior=strict
dtest_i2_r16_d1_tst_c dtest_i4_r16_d1_tst_c dtest_i8_r16_d1_tst_c dtest_i2_r16_d0_tst_c dtest_i4_r16_d0_tst_c dtest_i8_r16_d0_tst_c: \
	FC = $(DFORT) -ffp-exception-behavior=strict

# LLVM Flang
FFORT = flang -std=f$(FSTD) -Mstandard -Wall -Wextra
ftest_i2_r4_d1_tst_c ftest_i4_r4_d1_tst_c ftest_i8_r4_d1_tst_c ftest_i2_r4_d0_tst_c ftest_i4_r4_d0_tst_c ftest_i8_r4_d0_tst_c: \
	FC = $(FFORT)
ftest_i2_r8_d1_tst_c ftest_i4_r8_d1_tst_c ftest_i8_r8_d1_tst_c ftest_i2_r8_d0_tst_c ftest_i4_r8_d0_tst_c ftest_i8_r8_d0_tst_c: \
	FC = $(FFORT)
ftest_i2_r16_d1_tst_c ftest_i4_r16_d1_tst_c ftest_i8_r16_d1_tst_c ftest_i2_r16_d0_tst_c ftest_i4_r16_d0_tst_c ftest_i8_r16_d0_tst_c: \
	FC = $(FFORT)

# GNU gfortran
# In the debug mode, our code includes the BACKTRACE function if the compiler is gfortran. This
# makes the code not standard-conforming. So -std=f$(FSTD) is excluded for the following options.
GFORT = gfortran -Wall -Wextra -pedantic -Wampersand -Wconversion  -Wuninitialized \
	-Wmaybe-uninitialized -Wsurprising -Waliasing  -Wimplicit-interface -Wimplicit-procedure \
	-Wintrinsics-std -Wunderflow -Wuse-without-only -Wrealloc-lhs -Wrealloc-lhs-all -Wdo-subscript \
	-Wunused-parameter -fPIC -fimplicit-none -fbacktrace -fcheck=all \
	-finit-real=nan -finit-integer=-9999999
gtest_i2_r4_d1_tst_c gtest_i4_r4_d1_tst_c gtest_i8_r4_d1_tst_c gtest_i2_r4_d0_tst_c gtest_i4_r4_d0_tst_c gtest_i8_r4_d0_tst_c: \
	FC = $(GFORT) -ffpe-trap=zero
gtest_i2_r8_d1_tst_c gtest_i4_r8_d1_tst_c gtest_i8_r8_d1_tst_c gtest_i2_r8_d0_tst_c gtest_i4_r8_d0_tst_c gtest_i8_r8_d0_tst_c: \
	FC = $(GFORT) -ffpe-trap=zero,invalid,overflow,#,underflow,denorm
gtest_i2_r16_d1_tst_c gtest_i4_r16_d1_tst_c gtest_i8_r16_d1_tst_c gtest_i2_r16_d0_tst_c gtest_i4_r16_d0_tst_c gtest_i8_r16_d0_tst_c: \
	FC = $(GFORT) -ffpe-trap=zero,invalid,overflow,#,underflow,denorm

# Intel ifort
IFORT = ifort -stand f$(FS) -warn all -check all -debug extended -fimplicit-none \
	-traceback -debug-parameters all -fp-stack-check
itest_i2_r4_d1_tst_c itest_i4_r4_d1_tst_c itest_i8_r4_d1_tst_c itest_i2_r4_d0_tst_c itest_i4_r4_d0_tst_c itest_i8_r4_d0_tst_c: \
	FC = $(IFORT) -fp-trap=divzero
itest_i2_r8_d1_tst_c itest_i4_r8_d1_tst_c itest_i8_r8_d1_tst_c itest_i2_r8_d0_tst_c itest_i4_r8_d0_tst_c itest_i8_r8_d0_tst_c: \
	FC = $(IFORT) -ftrapuv -init=snan,array -fpe0 -fpe-all=0 -assume ieee_fpe_flags \
	-fp-trap=divzero,invalid,overflow#,underflow,denormal
	#-no-ftz -fp-model strict
itest_i2_r16_d1_tst_c itest_i4_r16_d1_tst_c itest_i8_r16_d1_tst_c itest_i2_r16_d0_tst_c itest_i4_r16_d0_tst_c itest_i8_r16_d0_tst_c: \
	FC = $(IFORT) -ftrapuv -init=snan,array -fpe0 -fpe-all=0 -assume ieee_fpe_flags \
	-fp-trap=divzero,invalid,overflow#,underflow,denormal
	#-no-ftz -fp-model strict

# NAG nagfor
NFORT = nagfor -colour=error:red,warn:magenta,info:cyan \
	-f$(FSTD) -info -gline -u -C -C=alias -C=dangling -C=intovf -C=undefined -kind=unique \
	-Warn=allocation -Warn=constant_coindexing -Warn=subnormal
ntest_i2_r4_d1_tst_c ntest_i4_r4_d1_tst_c ntest_i8_r4_d1_tst_c ntest_i2_r4_d0_tst_c ntest_i4_r4_d0_tst_c ntest_i8_r4_d0_tst_c: \
	FC = $(NFORT) -nan -ieee=full
ntest_i2_r8_d1_tst_c ntest_i4_r8_d1_tst_c ntest_i8_r8_d1_tst_c ntest_i2_r8_d0_tst_c ntest_i4_r8_d0_tst_c ntest_i8_r8_d0_tst_c: \
	FC = $(NFORT) -nan -ieee=stop
ntest_i2_r16_d1_tst_c ntest_i4_r16_d1_tst_c ntest_i8_r16_d1_tst_c ntest_i2_r16_d0_tst_c ntest_i4_r16_d0_tst_c ntest_i8_r16_d0_tst_c: \
	FC = $(NFORT) -nan -ieee=stop

# NVIDIA nvfortran (aka, pgfortran)
VFORT = nvfortran -C -Mstandard -Minform=warn -Mbounds -Mchkstk -Mchkptr
vtest_i2_r4_d1_tst_c vtest_i4_r4_d1_tst_c vtest_i8_r4_d1_tst_c vtest_i2_r4_d0_tst_c vtest_i4_r4_d0_tst_c vtest_i8_r4_d0_tst_c: \
	FC = $(VFORT) -Kieee -Ktrap=divz
vtest_i2_r8_d1_tst_c vtest_i4_r8_d1_tst_c vtest_i8_r8_d1_tst_c vtest_i2_r8_d0_tst_c vtest_i4_r8_d0_tst_c vtest_i8_r8_d0_tst_c: \
	FC = $(VFORT) -Kieee -Ktrap=divz,ovf,inv#,unf,denorm
vtest_i2_r16_d1_tst_c vtest_i4_r16_d1_tst_c vtest_i8_r16_d1_tst_c vtest_i2_r16_d0_tst_c vtest_i4_r16_d0_tst_c vtest_i8_r16_d0_tst_c: \
	FC = $(VFORT) -Kieee -Ktrap=divz,ovf,inv#,unf,denorm

# Oracle sunf95
SFORT = sunf95 -w3 -u -U -ansi -xcheck=%all -C
stest_i2_r4_d1_tst_c stest_i4_r4_d1_tst_c stest_i8_r4_d1_tst_c stest_i2_r4_d0_tst_c stest_i4_r4_d0_tst_c stest_i8_r4_d0_tst_c: \
	FC = $(SFORT) -fnonstd -ftrap=division
stest_i2_r8_d1_tst_c stest_i4_r8_d1_tst_c stest_i8_r8_d1_tst_c stest_i2_r8_d0_tst_c stest_i4_r8_d0_tst_c stest_i8_r8_d0_tst_c: \
	FC = $(SFORT) \
	-fnonstd -ftrap=overflow,division,invalid#,underflow
stest_i2_r16_d1_tst_c stest_i4_r16_d1_tst_c stest_i8_r16_d1_tst_c stest_i2_r16_d0_tst_c stest_i4_r16_d0_tst_c stest_i8_r16_d0_tst_c: \
	FC = $(SFORT) \
	-fnonstd -ftrap=overflow,division,invalid#,underflow

# Intel ifx
XFORT = ifx -stand f$(FS) -warn all -check all -debug extended -fimplicit-none \
	-traceback -debug-parameters all -fp-stack-check
xtest_i2_r4_d1_tst_c xtest_i4_r4_d1_tst_c xtest_i8_r4_d1_tst_c xtest_i2_r4_d0_tst_c xtest_i4_r4_d0_tst_c xtest_i8_r4_d0_tst_c: \
	FC = $(XFORT) -fp-trap=divzero
xtest_i2_r8_d1_tst_c xtest_i4_r8_d1_tst_c xtest_i8_r8_d1_tst_c xtest_i2_r8_d0_tst_c xtest_i4_r8_d0_tst_c xtest_i8_r8_d0_tst_c: \
	FC = $(XFORT) -ftrapuv -init=snan,array -fpe0 -fpe-all=0 -assume ieee_fpe_flags \
	-fp-trap=divzero,invalid,overflow#,underflow,denormal
	#-no-ftz -fp-model strict
xtest_i2_r16_d1_tst_c xtest_i4_r16_d1_tst_c xtest_i8_r16_d1_tst_c xtest_i2_r16_d0_tst_c xtest_i4_r16_d0_tst_c xtest_i8_r16_d0_tst_c: \
	FC = $(XFORT) -ftrapuv -init=snan,array -fpe0 -fpe-all=0 -assume ieee_fpe_flags \
	-fp-trap=divzero,invalid,overflow#,underflow,denormal
	#-no-ftz -fp-model strict

# G95
9FORT = g95 -std=f$(FSTD) -pedantic -Wall -Wextra \
	-Wimplicit-none -Wline-truncation -Wprecision-loss -Wunused-module-vars -Wunused-vars -Wunset-vars \
	-fimplicit-none -fbounds-check -ftrace=full
9test_i2_r4_d1_tst_c 9test_i4_r4_d1_tst_c 9test_i8_r4_d1_tst_c 9test_i2_r4_d0_tst_c 9test_i4_r4_d0_tst_c 9test_i8_r4_d0_tst_c: \
	FC = $(9FORT)
9test_i2_r8_d1_tst_c 9test_i4_r8_d1_tst_c 9test_i8_r8_d1_tst_c 9test_i2_r8_d0_tst_c 9test_i4_r8_d0_tst_c 9test_i8_r8_d0_tst_c: \
	FC = $(9FORT)
9test_i2_r16_d1_tst_c 9test_i4_r16_d1_tst_c 9test_i8_r16_d1_tst_c 9test_i2_r16_d0_tst_c 9test_i4_r16_d0_tst_c 9test_i8_r16_d0_tst_c: \
	FC = $(9FORT)

####################################################################################################
# All the tests.
test:
	make $(TESTS)

test_c:
	make $(TESTS_C)

####################################################################################################
# Make a compiler-specific test.
######################################################################################
# N.B.:
# 1. Execute CHCKTST by  "bash $(CHCKTST)" instead of just "$(CHCKTST)", because "$(CHCKTST)" may
# not be executable on all operating systems.
# 2. The log for itest or itest_i2 will be itest_(STAMP). Similar for other tests.
# 3. In the following, `@make $(TST_C)` will trigger `@make $(SUBTESTS_C)`, which compile the code
# for all subtests. Then `@make $(SUBTESTS)` will test the binaries. We not test any binary until
# the code can compile in all cases.
$(TESTS) $(TESTS_INT):
	@mkdir -p $(LOG_DIR)
	@printf "\n$@ starts.\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@make $(TST_C)
	@make --jobs $(NPROCS) $(SUBTESTS)
	bash $(CHCKTST) --warning "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@printf "\n$@ ends!\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@mv "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log" "$(LOG_DIR)/$@_$(STAMP).log"
	@make clean

# Make the binary corresponding to a test in TESTS_C or TESTS_INT_C, but do not execute it.
# This is useful if we want to check whether the code can compile.
$(TESTS_C) $(TESTS_INT_C):
	@mkdir -p $(LOG_DIR)
	@printf "\n$@ starts.\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@make $(SUBTESTS_C)
	bash $(CHCKTST) --warning "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@printf "\n$@ ends!\n\n" | tee -a "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@mv "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log" "$(LOG_DIR)/$@_$(STAMP).log"
	@make cleanmisc

# Make a compiler-specific subtest.
######################################################################################
# N.B.: The prerequisite should NOT include files that may not exist, e.g., $(SRC), because
# Make will ignore the rule if such files do not exist, resulting in "No rule to make ..." mistake.
%_tst: %_tst_c
	@mkdir -p $(LOG_DIR)
	@printf "\n$@ starts.\n\n" | tee -a "$(LOG_DIR)/$@.log"
	@if echo $@ | grep -q 9test ; then \
		printf "\n$@ is skipped!\n\n" ; \
	else \
		./$< 2>&1 | tee -a "$(LOG_DIR)/$@.log" ; \
	fi
	bash $(CHCKTST) --error "$(LOG_DIR)/$@.log"
	bash $(CHCKTST) --warning "$(LOG_DIR)/$@.log"
	@printf "\n$@ ends at $(shell date +%Y.%m.%d_%H.%M.%S).\n\n" | tee -a "$(LOG_DIR)/$@.log"
	@cat "$(LOG_DIR)/$@.log" >> "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*//").log"
	@rm "$(LOG_DIR)/$@.log"
	@make cleanmisc

# Make the binary corresponding to %_tst_c, but do not execute it.
# This is useful if we want to check whether the code can compile.
%_tst_c: source_% header_%
	@mkdir -p $(LOG_DIR)
	@printf "\n$@ starts.\n\n" | tee -a "$(LOG_DIR)/$@.log"
	$(FC) $(FFLAGS) -o $@ $(SRC) 2>&1 | tee -a "$(LOG_DIR)/$@.log"
	bash $(CHCKTST) --error "$(LOG_DIR)/$@.log"
	bash $(CHCKTST) --warning "$(LOG_DIR)/$@.log"
	@printf "\n$@ ends at $(shell date +%Y.%m.%d_%H.%M.%S).\n\n" | tee -a "$(LOG_DIR)/$@.log"
	@cat "$(LOG_DIR)/$@.log" >> "$(LOG_DIR)/$(shell echo $@ | sed "s/_.*/_c/").log"
	@rm "$(LOG_DIR)/$@.log"
	@make cleanmisc
	#touch $@  # Without this line, %_tst_c is remade even if it is up to date. (Better approach???)

# Make a local copy of the source code for the test.
source_%: $(SRC_DIRS)
	@printf "\nMaking a copy of the source code for the test.\n"
	@for DIR in $(SRC_DIRS); do cp -r "$$DIR" ./; done
	@for FILE in $(DRIVER_SRC); do cp $(DRIVER_DIR)/"$$FILE" ./; done
	@find ./ -type f  \
		\( -name '*.mod' \
		-o -name '*.o' \
		-o -name '*.dbg' \
		-o -name '*.cmdx' \
		-o -name '*.cmod' \
		-o -name '*.ilm' \
		-o -name '*.stb' \
		-o -name '*.out' \
		-o -name '*__genmod.f90' \
		\)  -exec rm "{}" +  # Cleaning up; important!!!
	@printf "\nDone.\n\n"

# Adapt the header file for the test.
header_%: IK = $(shell expr 8 \* $$(echo $@ | sed "s/.*_i//" | sed "s/_.*//"))
header_%: RP = $(shell expr 8 \* $$(echo $@ | sed "s/.*_r//" | sed "s/_.*//"))
header_%: DBG = $(shell echo $@ | sed "s/.*_d//" | sed "s/_.*//")
header_%: QPAVLB = $(shell expr $$(echo $@ | sed "s/.*_r//" | sed "s/_.*//") / 16)
header_%: source_%
	@printf "\nPreparing the header file for the test.\n"
	$(SED) "0,/^#define __QP_AVAILABLE__ [0-9]*/s//#define __QP_AVAILABLE__ $(QPAVLB)/" $(HEADERS)
	$(SED) "0,/^#define __INTEGER_KIND__ [0-9]*/s//#define __INTEGER_KIND__ $(IK)/" $(HEADERS)
	$(SED) "0,/^#define __REAL_PRECISION__ [0-9]*/s//#define __REAL_PRECISION__ $(RP)/" $(HEADERS)
	$(SED) "0,/^#define __DEBUGGING__ [0-9]*/s//#define __DEBUGGING__ $(DBG)/" $(HEADERS)
	@printf "\nDone.\n\n"


####################################################################################################
# Cleaning up.
cleanbin:
	@printf "\nCleaning up the binaries ...\n"
	@rm -f *_tst_c
	@printf "\nDone.\n\n"

cleanmisc:
	@printf "\nCleaning up miscellaneous files ...\n"
	@rm -f *.o *.mod *.dbg *.cmdx *.cmod *.ilm *.stb *.out *__genmod.f90
	@rm -f *_output.txt
	@printf "\nDone.\n\n"

cleansrc:
	@printf "\nCleaning up the source code ...\n"
	@for ITEM in $(COMMON) $(SOLVER) $(TESTSUITE) $(DRIVER_SRC) ; do  \
		if [ `ls -1 "$$ITEM" 2>/dev/null | wc -l ` -gt 0 ] ; \
			then mkdir -p $(TRASH_DIR); rm -rf $(TRASH_DIR)/"$$ITEM"; \
			mv "$$ITEM" $(TRASH_DIR) > /dev/null 2>&1; \
		fi ; \
	done
	@printf "\nDone.\n\n"

clean: cleanbin cleanmisc cleansrc

cleanall: clean
	rm -rf $(TRASH_DIR) $(LOG_DIR)
