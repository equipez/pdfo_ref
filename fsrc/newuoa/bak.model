      integer :: tr, maxtr
      logical :: model_step, reduce_rho, shortd 

      maxtr = 1000*n  ! Maximal numer of trust region iterations
      info = 0
      prederr = zero
      nfsave = nf

      do tr = 1, maxtr

          ! Will we improve the model after the trust region iteration?
          model_step = false  
          ! Will we reduce rho after the trust region iteration?
          reduce_rho = false  
          ! NEWUOA never sets MODEL_STEP = REDUCE_RHO = .TRUE.

          ! Exit if the model contains NaN. Otherwise, the behaviour of
          ! TRSAPP is unpredictable, and Segmentation Fault may occur.
          ! We may build a new model instead of exiting.
          if (any(is_nan(gq)) .or. any(is_nan(hq)) .or. any(is_nan(pq)))&
     &     then
              info = -3
              exit
          end if

          ! Solve the trust region subproblem
          call trsapp (n, npt, xopt, xpt, gq, hq, pq, delta, d, w,      &
     &     w(n+1), w(2*n+1), w(3*n+1), crvmin)

          ! Calculate the length of the trial step D.
          !dsq = dot_product(d, d)
          dsq = zero
          do i = 1, n
              dsq = dsq + d(i)**2
          end do
          dnorm = min(delta, sqrt(dsq))

          ! NFSAVE is counter of the latest function evaluation with 
          ! ||D|| > RHO
          r
          if (dnorm > rho) then 
              nfsave = nf
          end if

          ! Is the trial step long enough to invoke a function evaluation?
          if (dnorm >= half*rho) then
              shortd = .false.
          else
              shortd = .true.
              if (0.125_rp*crvmin*rho*rho <= maxval(abs(prederr)) .or.  &
     &         nf <= nfsave + 2) then 
                  ! The first possibility (out of two) that reduce_rho is true
                  reduce_rho = .true.  
              else ! Three recent values of ||d_k|| and |Fâˆ’Q| are small.
                  delta = tenth*delta  ! Reduce DELTA by a factor of 10
                  ! After this, DELTA < DNORM may happen, explaining why 
                  ! we sometimes write MAX(DELTA, DNORM).
              end if
          end if
    
          if (.not. shortd)
              ! Shift XBASE if XOPT may be too far from XBASE.
              if (dsq <= 1.0e-3_rp*xoptsq) then
                  call shiftbase(n, npt, idz, xopt, pq, bmat, zmat, gq, &
     &             hq, xpt)
                  xbase = xbase + xopt
                  xopt = zero
                  xoptsq = zero
              end if
    
              ! Calculate VLAG and BETA for D. The first NPT components
              ! of W_check will be held in WCHECK.
              !call vlagbeta(n, npt, idz, kopt, bmat, zmat, xpt, xopt, d,&
     !&         vlag, beta, wcheck)
              call vlagbeta(n, npt, idz, kopt, bmat, zmat, xpt, xopt, d,&
     &         vlag, beta, wcheck, dsq, xoptsq)

!----------------------------------------------------------------------------!
              ! Use the quadratic model to predict the change in F due
              ! to the step D.
              !call calquad(vquad, d, xopt, xpt, gq, hq, pq, n, npt)
              call calquad(vquad, d, xopt, xpt, gq, hq, pq, n, npt,     &
     &         wcheck(1:npt))

              ! Calculate the next value of the objective function.
              xnew = xopt + d
              x = xbase + xnew
              if (any(is_nan(x))) then
                  f = sum(x)  ! Set F to NaN. It is necessary.
                  info = -1
                  exit
              else
                  call calfun(n, x, f)
                  nf = nf + 1
              end if

              ! PREDERR saves the error of this prediction for 3 most
              ! recent three models.
              prederr(2 : size(prederr)) = prederr(1 : size(prederr)-1)
              prederr(1) = f - fopt - vquad
        
              ! Update FOPT and XOPT
              ! FSAVE is needed later when setting MODEL_STEP 
              ! and REDUCE_RHO.
              fsave = fopt  
              if (f < fopt) then
                  fopt = f
                  xopt = xnew
                  xoptsq = zero
                  do i = 1, n
                      xoptsq = xoptsq + xopt(i)**2
                  end do
              end if
              ! Exit if F is NaN or INF. 
              if (is_nan(f) .or. is_posinf(f)) then 
                  info = -2
                  exit
              end if
              ! Exit if F <= FTARGET.
              if (f <= ftarget) then
                  info = 1
                  exit
              end if
              ! Exit if NF >= NFTEST
              if (nf >= nftest) then
                  info = 3
                  exit
              end if

      !----------------------------------------------------------------!
    
              if (is_nan(vquad) .or. vquad >= zero) then
                  info = 2
                  exit
              end if
              ratio = (f - fsave)/vquad
              if (ratio <= tenth) then
                  delta = half*dnorm
              else if (ratio <= 0.7_rp) then
                  delta = max(half*delta, dnorm)
              else
                  delta = max(half*delta, dnorm + dnorm)
              end if
              if (delta <= 1.5_rp*rho) then
                  delta = rho
              end if
              
              ! Set KNEW to the index of the next interpolation point
              ! to delete.
              rhosq = max(tenth*delta, rho)**2
              do k = 1, npt
                  hdiag(k) = -sum(zmat(k, 1 : idz - 1)**2) +            &
     &             sum(zmat(k, idz : npt - n - 1)**2)
                  xdiff = xpt(k, :) - xopt
                  xdsq(k) = dot_product(xdiff, xdiff) 
              end do
              sigma = abs(beta*hdiag + vlag(1 : npt)**2)
              sigma = sigma * max(xdsq/rhosq, one)**3
              if (f >= fsave) then
              ! Set SIGMA(KOPT) = -1 to prevent KNEW from being KOPT 
                  sigma(kopt) = -one  
              end if 
              if (maxval(sigma) > one .or. f < fsave) then
              ! KNEW > 0 unless MAXVAL(SIGMA) <= 1 and F >= FSAVE
                  knew = maxloc(sigma, 1)
              else
                  knew = 0
              end if
        
              if (knew > 0) then
                  ! Update BMAT, ZMAT and IDZ, so that the KNEW-th 
                  ! interpolation point can be moved. 
                  call update(n, npt, bmat, zmat, idz, ndim, vlag, beta,&
     &             knew, w)
                  ! Update the quadratic model
                  call updateq(n, npt, idz, knew, prederr(1),           &
     &             xpt(knew, :), bmat(knew, :), zmat, gq, hq, pq)
    
                  ! Include the new interpolation point. This should be 
                  ! done after updating BMAT, ZMAT, and the model.
                  fval(knew) = f
                  xpt(knew, :) = xnew
    
                  ! If a trust region step makes a small change to the 
                  ! objective function, then calculate the gradient of 
                  ! the least Frobenius norm interpolant at XBASE,
                  ! using VLAG for a vector of right hand sides.
                  if (delta == rho) then
                  ! Zaikun 2019-08-26: It is observed in Zhang Zaikun's PhD
                  ! thesis (Section 3.3.2) that it is more reasonable and more
                  ! efficient to check the value of RATIO instead of ABS(RATIO).
                      ! IF (DABS(RATIO) .GT. 1.0D-2) THEN
                      if (ratio > 1.0e-2_rp) then
                          itest = 0
                      else
                          gqsq = zero
                          do i = 1, n
                              gqsq = gqsq + gq(i)**2
                          end do
                          vlag(1 : npt) = fval - fval(kopt)
                           
                          !galt = matmul(vlag(1 : npt), bmat(1 : npt, 1 : n))
                          !galtsq = dot_product(galt, galt)
                          galt = zero
                          do k = 1, npt
                              galt = galt + vlag(k)*bmat(k, :)
                          end do
                          galtsq = zero
                          do i = 1, n
                              galtsq = galtsq + galt(i)*galt(i) 
                          end do
            
                          ! Test whether to replace the new quadratic model by the
                          ! least Frobenius norm interpolant, making the replacement
                          ! if the test is satisfied.
                          if (gqsq < 100.0_rp*galtsq) then
                              itest = 0
                          else
                              itest = itest + 1
                          end if
                      end if
                  end if

                  if (itest >= 3) then
                      call qalt(gq, hq, pq, fval, bmat(1 : npt, :),     &
     &                 zmat, n, npt, kopt, idz)
                      itest = 0
                  end if
        
!                  update kopt = knew if f<fsave
!                  update kopt = knew if ratio > zero 
                  if (f < fsave) then 
                      kopt = knew
                  end if
!                  if (f <= fsave + tenth*vquad) then  ! (ratio < tenth)
!                       model_step = .false.
!                       ! When f > fsave + tenth*vquad, model_step is not
!                       ! necessarily true.
!                  end if 
              end if
          end if
    
!          if (((.not. shortd) .and. (ratio < tenth .or. knew == 0))     &
!     &        .or. (shortd .and. .not. reduce_rho)) then
          if (((.not. shortd) .and. (f>fsave+tenth*vquad .or. knew==0)) &
     &     .or. (shortd .and. .not. reduce_rho)) then
              
              ! Find out if the interpolation points are close enough to
              ! the best point so far.
              distsq = 4.0_rp*delta*delta
              do k = 1, npt
                  xdiff = xpt(k, :) - xopt
                  xdsq(k) = dot_product(xdiff, xdiff)
              end do
              if (maxval(xdsq) > distsq) then
                  knew = maxloc(xdsq, 1)
                  distsq = maxval(xdsq)
              else
                  knew = 0
              end if
            
              ! If KNEW is positive, then set DSTEP, and branch back for
              ! the  next iteration, which will generate a "model step".
!              model_step = (knew > 0)
!              reduce_rho = (knew == 0 .and. ratio <= 0 .and.            &
!     &         max(delta, dnorm) <= rho)
              if (knew > 0) then
                  ! The only possibility that model_step is true
                  model_step = .true. 
              elseif(max(delta,dnorm)<=rho .and. (ratio<=0 .or. shortd))&
     &         then
                  ! The second possibility (out of two) that reduce_rho is true
                  reduce_rho = .true.
              end if
          end if 

          if (reduce_rho) then
              ! The calculations with the current value of RHO are complete.
              ! Pick the next values of RHO and DELTA.
              if (rho > rhoend) then
                  delta = half*rho
                  ratio = rho/rhoend
                  if (ratio <= 16.0_rp) then
                      rho = rhoend
                  else if (ratio <= 250.0_rp) then
                      rho = sqrt(ratio)*rhoend
                  else
                      rho = tenth*rho
                  end if
                  delta = max(delta, rho)
                  nfsave = nf
              else
                  info = 0
                  exit
              end if
          end if

          if (model_step) then
              ! Set DSTEP, which will be used as the trust region radius
              ! for the model-improving schemes BIGLAG and BIGDEN. We 
              ! also need it to decide whether to shift XBASE or not.
              dstep = max(min(tenth*sqrt(distsq), half*delta), rho)
              dsq = dstep*dstep

              ! Shift XBASE if XOPT may be too far from XBASE.
              if (dsq <= 1.0e-3_rp*xoptsq) then
                  call shiftbase(n, npt, idz, xopt, pq, bmat, zmat, gq, &
     &             hq, xpt)
                  xbase = xbase + xopt
                  xopt = zero
                  xoptsq = zero
              end if

              ! Exit if BMAT or ZMAT contains NaN. Otherwise, the 
              ! behaviour of BIGLAG and BIGDEN is unpredictable. 
              ! Segmentation Fault may occur.
              if (any(is_nan(bmat)) .or. any(is_nan(zmat))) then
                  info = -3
                  exit
              end if

              call biglag(n, npt, xopt, xpt, bmat, zmat, idz, ndim,     &
     &         knew, dstep, d, alpha, vlag, vlag(npt + 1), w, w(n+1),   &
     &         w(2*n+1))

              ! Calculate VLAG, BETA, and WCHECK for D.
!              call vlagbeta(n, npt, idz, kopt, bmat, zmat, xpt, xopt, d,&
!     &         vlag, beta, wcheck)
              call vlagbeta(n, npt, idz, kopt, bmat, zmat, xpt, xopt, d,&
     &         vlag, beta, wcheck, dsq, xoptsq)

              ! If KNEW is positive and if the cancellation in DENOM is
              ! unacceptable, then BIGDEN calculates an alternative model
              ! step, XNEW being used for working space.
              ! No need to check whether BMAT and ZMAT contain NaN as no
              ! change has been made to them.
              if (abs(one + alpha*beta/vlag(knew)**2) <= 0.8_rp) then
                  call bigden (n, npt, xopt, xpt, bmat, zmat, idz, ndim,&
     &             kopt, knew, d, wcheck, vlag, beta, xnew, w(ndim+1),  &
     &             w(6*ndim+1))
              end if
 
      !----------------------------------------------------------------!
              ! Use the quadratic model to predict the change in F due 
              ! to the step D. 
              !call calquad(vquad, d, xopt, xpt, gq, hq, pq, n, npt)
              call calquad(vquad, d, xopt, xpt, gq, hq, pq, n, npt,     &
     &         wcheck(1:npt))

              ! Calculate the next value of the objective function.
              xnew = xopt + d
              x = xbase + xnew
              if (any(is_nan(x))) then
                  f = sum(x)  ! Set F to NaN. It is necessary.
                  info = -1
                  exit
              else
                  call calfun(n, x, f)
                  nf = nf + 1
              end if
             
              ! PREDERR saves the error of this prediction for 3 most 
              ! recent three models.
              prederr(2 : size(prederr)) = prederr(1 : size(prederr)-1)
              prederr(1) = f - fopt - vquad
        
              ! Update FOPT and XOPT if the new F is the least value of 
              ! the objective function so far. 
              fsave = fopt
              if (f < fopt) then
                  fopt = f
                  xopt = xnew
                  xoptsq = zero
                  do i = 1, n
                      xoptsq = xoptsq + xopt(i)**2
                  end do
              end if

              if (is_nan(f) .or. is_posinf(f)) then 
                  info = -2
                  exit
              end if
              if (f <= ftarget) then
                  info = 1
                  exit
              end if
              if (nf >= nftest) then
                  info = 3
                  exit
              end if
!----------------------------------------------------------------------------!
    
              ! Update BMAT, ZMAT and IDZ, so that the KNEW-th interpolation
              ! point can be moved. 
              call update(n, npt, bmat, zmat, idz,ndim,vlag,beta,knew,w)
              ! Update the quadratic model.
              call updateq(n, npt, idz, knew, prederr(1), xpt(knew, :), &
     &         bmat(knew, :), zmat, gq, hq, pq)
    
              ! Include the new interpolation point. This should be done
              ! after updating BMAT, ZMAT, and the model.
              fval(knew) = f
              xpt(knew, :) = xnew
              if (f < fsave) then
                  kopt = knew
              end if

              ! The following seems different from what is introduced in 
              ! Section 7 (around (7.7)) of the NEUOA paper. Seemingly we 
              ! should keep dnorm=||d||.
              if (dnorm > rho) then 
                  nfsave = nf  !? dnorm is from last TR? 
              end if
          end if
      end do
