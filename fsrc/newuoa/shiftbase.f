      subroutine shiftbase(n, npt, idz, xopt, pq, bmat, zmat, gq,hq,xpt)

      use consts, only : rp, zero, half, quart
      implicit none

      integer, intent(in) :: idz, n, npt

      real(kind = rp), intent(in) :: xopt(n), pq(npt)
      real(kind = rp), intent(inout) :: bmat(npt + n, n),               &
     & zmat(npt, npt - n - 1), gq(n), hq((n*(n + 1))/2), xpt(npt, n)

      integer :: i, ih, j, k
      real(kind = rp) :: summation, summationz, temp, qxoptq, vlag(n),  &
     & xoptsq, w1(npt), w2(n), w3(npt), w4(n), bmatk(n)

      ! First make the changes to BMAT that do not depend on ZMAT.
      xoptsq = dot_product(xopt, xopt)
      qxoptq = quart * xoptsq

!      do k = 1, npt
!          summation = dot_product(xpt(k, :), xopt)
!          temp = pq(k)*summation
!          summation = summation - half*xoptsq
!          !w(npt + k) = summation
!          w1(k) = summation
!          do i = 1, n
!              gq(i) = gq(i) + temp*xpt(k, i)
!              xpt(k, i) = xpt(k, i) - half*xopt(i)
!              vlag(i) = bmat(k, i)
!              w2(i) = summation*xpt(k, i) + qxoptq*xopt(i)
!              do j = 1, i
!                  bmat(npt + i, j) = bmat(npt + i, j) + vlag(i)*w2(j) + &
!     &             w2(i)*vlag(j)
!              end do
!          end do
!      end do

      !----------------------------------------------------------------!   
      ! The update for gq can indeed be done by the following 3 lines:
      !real(kind = rp) :: hxopt(n)
      !call hessmul(n, npt, xpt, hq, pq, xopt, hxopt)
      !gq = gq + hxopt 
      !----------------------------------------------------------------!
      do k = 1, npt
      ! This is the update of GQ due to the implicit part of the HESSIAN    
      ! GQ = GQ + (\sum_{K=1}^NPT PQ(K)*XPT(K, :)'*XPT(K, :)) * XOPT
          gq = gq + pq(k)*dot_product(xpt(k, :), xopt)*xpt(k, :)
      end do

      w1 = matmul(xpt, xopt) - half*xoptsq
      ! W1 indeed equals MATMUL(XPT, XOPT) for the XPT generated by the
      ! following 3 lines.
      do k = 1, npt
          xpt(k, :) = xpt(k, :) - half*xopt
      end do

      do k = 1, npt
          bmatk = bmat(k, :)
          w2 = w1(k)*xpt(k, :) + qxoptq*xopt
          do i = 1, n
              bmat(npt + i, 1 : i) = bmat(npt + i, 1 : i) +             &
     &         bmatk(i)*w2(1:i) + w2(i)*bmatk(1:i)
          end do
      end do

      ! Then the revisions of BMAT that depend on ZMAT are calculated.
      do k = 1, npt - n - 1
          summationz = zero
          do i = 1, npt
              summationz = summationz + zmat(i, k)
!              w(i) = w(npt + i)*zmat(i, k)
              w3(i) = w1(i)*zmat(i, k)
          end do
          do j = 1, n
              summation = qxoptq*summationz*xopt(j)
              do i = 1, npt
                  summation = summation + w3(i)*xpt(i, j)
              end do
              vlag(j) = summation
              if (k < idz) summation = -summation
              do i = 1, npt
                  bmat(i, j) = bmat(i, j) + summation*zmat(i, k)
              end do
          end do
          do i = 1, n
              temp = vlag(i)
              if (k < idz) temp = -temp
              do j = 1, i
                  bmat(npt + i, j) = bmat(npt + i, j) + temp*vlag(j)
              end do
          end do
      end do

      do j = 1, n
          do i = 1, j
              bmat(npt + i, j) = bmat(npt + j, i)
          end do
      end do

      ! The following instructions complete the shift of XBASE,
      ! including the changes to the parameters of the quadratic model.
      ih = 0
      do j = 1, n
          w4(j) = zero
          do k = 1, npt
              w4(j) = w4(j) + pq(k)*xpt(k, j)
              xpt(k, j) = xpt(k, j) - half*xopt(j)
          end do
          do i = 1, j
              ih = ih + 1
              if (i < j) gq(j) = gq(j) + hq(ih)*xopt(i)
              gq(i) = gq(i) + hq(ih)*xopt(j)
              hq(ih) = hq(ih) + w4(i)*xopt(j) + xopt(i)*w4(j)
          end do
      end do

      return 

      end subroutine shiftbase
