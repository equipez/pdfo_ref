! TODO:
! The COBYLA in ./neupdfo.1 and ./neupdfo.2 did not behave the same as OPDFO/cobyla therein on
! problem BQP1VAR, the 10the run. Find out why, and check whether the new version gets rid of the problem.
!
! Write a note on the algorithm of trstlp. Rewrite the subroutine using the language of QR
! facorization. Rewrite the VMD function. See the comments in trustregion.f90.
! The following functions will be useful, and they can be included into linalg:
! qradd(Q, a, R optional, Rdiag optional) : add a new column
! qrdel(Q, i, R optional, Rdiag optional) : remove a column
! qrexc(Q, i, j, R optional, Rdiag optional) : exchange two columns
! lsqr(A, x, Q optional, R optional, Rdiag options) : linear least squares
!---------------------------------------------------------------------------!
!-- QUESTION: What are exactly the objective and algorithm of trstlp_sub? --!
! The algorithm was NOT documented in the COBYLA paper. A note should be
! written to introduce it!
! As a major part of the algorithm, the code maintains and updates the QR
! factorization of A(IACT(1:NACT)), i.e., the gradients of all the active
! (linear) constraints. The matrix Z is indeed Q, and the vector ZDOTA
! is the diagonal of R. The factorization is updated by Givens rotations when
! an index is added in or removed from IACT.
! Zaikun 20211011: This subroutine SHOULD BE rewritten to make the update of
! the QR factorization more manifested. Include subroutines that update the
! factorization when IACT is changed by one element !!!!!!!!!!!!!!!!!!!!!!!!!
! This is related to the VMD function (see the end of the module). Also, note
! that in stage 2 the last index in IACT is always M+1, corresponding to the
! (linear) objective function.
! The following functions will be useful, and they can be included into linalg:
! qradd(A, Q, a, R optional, Rdiag optional) : add a new column
! qrdel(A, Q, i, R optional, Rdiag optional) : remove a column
! qrexc(A, Q, i, j, R optional, Rdiag optional) : exchange two columns
! lsqr(A, x, Q optional, R optional, Rdiag options) : linear least squares
!---------------------------------------------------------------------------!
!
! The Q (Z) in the QR factorization of A(:, IACT(1:NACT)) may lose orthogonality. How to
! to re-orthogonalize?
!
! BTW, write a projection function to be used in TRSAPP, BIGLAG, BIGDEN in NEWUOA. See lines 305-306
! of trustregion.f90 and 391-392, 675-676 of geometry.f90 of NEWUOA.
!
! PLANEROT is not in its final version. Adapt OPDFO/cobyla/trstlp.f90 so that the better version of
! PLANEROT can be taken. This version will suffer from over/underflow; also the modernized NEWUOA
! will not behave the same as the original one due to this version of PLANEROT.
!
! HYPOT is used  in trustregion.f90 for updating ZDOTA. A robust version should be written (avoid
! under/overflow in particular). This version may also be used in PLANEROT. This has been done
! previously, but it
! worsened a bit the performance of NEWUOA so it was discarded. Find it back, and test NEWUOA again.
!
! Try calculating ZDOTA from scratch (only the elements that change; there are 1 or 2 of them) instead of
! updating it. Is it more stable? Will it improve (at least not worsen) the performance of COBYLA?
! Needs tests. If it is accepted, then HYPOT is not needed.
!
! 0. In COBYLA, check what should we do with JDROP = 0, both TR and GEO
!    If ACTREM > 0 ===> JDROP > 0, why can COBYLA return sub-optimal points???
! 1. evalfc, extreme barrier, moderate excessively negative objective, which has not been done in
!    NEWUOA. Shouldn't we remove the extreme barrier in the MATLAB/Python interface after it is
!    implemented in FORTRAN?
! 3. merge UPDATEPOLE and UPDATEXFC
! 6. Do the same for NEWUOA
! 8. knew ===> jdrop
! 9. XPT(i, :), FVAL(:) should be indexed by j; k is for iterations (fhist and ffilt)
! 10. Check MAXVAL/MAXLOC --- are they affected by NaN?
! 11.
! Enforcing programming contracts
! Programming can be thought of as requirements for correct execution of a procedure and assurances
! for the result of correct execution. The requirements and assurances might be constraints of three
! kinds:
! Preconditions (requirements): logical expressions that must evaluate to .true. when a procedure starts execution,
! Postconditions (assurances): expressions that must evaluate to .true. when a procedure finishes execution, and
! Invariants: universal pre- and postconditions that must always be true when all procedures in a class start or finish executing.
